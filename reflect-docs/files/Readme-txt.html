<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><title>Readme - Reflect</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script><script language=JavaScript src="../javascript/searchdata.js"></script></head><body class="ContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.4 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CFile"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="Readme"></a>Readme</h1><div class=CBody><p>Reflect is a cohesive framework for doing runtime-type-identification (RTTI) and serialization in C++.&nbsp;  Reflect provides tools to identify, save, load, inspect and edit reflected objects.</p><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#Readme" >Readme</a></td><td class=SDescription>Reflect is a cohesive framework for doing runtime-type-identification (RTTI) and serialization in C++. </td></tr><tr class="SSection"><td class=SEntry><a href="#Overview" >Overview</a></td><td class=SDescription>What Reflect is and why you want to use it.</td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Features" >Features</a></td><td class=SDescription>Reflect is a complete C++ RTTI framework. </td></tr><tr class="SGeneric SIndent1"><td class=SEntry><a href="#Replaces_RTTI" >Replaces RTTI</a></td><td class=SDescription>Reflect does not depend on C++&rsquo;s built-in RTTI: typeid and dynamic_cast. </td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#The_Two_Faces_of_Reflection" >The Two Faces of Reflection</a></td><td class=SDescription>Reflect, mirroring C++, has two faces: <b>static</b> information known at compiletime, and <b>dynamic</b> information, known at runtime. </td></tr><tr class="SGeneric SIndent1"><td class=SEntry><a href="#Unit_Testing" >Unit Testing</a></td><td class=SDescription>Reflect includes its own Unit-<a href="include/reflect/test/Test-h.html#Test" class=LClass id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">Test</a> framework. </td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Philosophy" >Philosophy</a></td><td class=SDescription></td></tr><tr class="SSection"><td class=SEntry><a href="#Tutorial" >Tutorial</a></td><td class=SDescription>Or: Let&rsquo;s see some examples already.</td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Declaring_Reflection" >Declaring Reflection</a></td><td class=SDescription>Suppose you want to represent Circles by center and radius, you plan to make circle subclass Shape, so it should be at least Dynamic. </td></tr><tr class="SGeneric SIndent1"><td class=SEntry><a href="#Defining_Reflection" >Defining Reflection</a></td><td class=SDescription>At this point we have defined the circle type, and declared it and the inner Point type reflected. </td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Using_Reflection" >Using Reflection</a></td><td class=SDescription>Some uses of the reflected Circle class</td></tr><tr class="SSection"><td class=SEntry><a href="#Implementation" >Implementation</a></td><td class=SDescription>The nitty-gritty details.</td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Signature_and_Dynamic" >Signature and Dynamic</a></td><td class=SDescription>At the center of all of reflect are <a href="include/reflect/Signature-h.html#Signature" class=LClass id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">Signature</a> and <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">Dynamic</a>. </td></tr><tr class="SGeneric SIndent1"><td class=SEntry><a href="#Variants" >Variants</a></td><td class=SDescription><a href="include/reflect/Variant-h.html#Variant" class=LClass id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">Variant</a> provides a nice way of wrapping up a static type with some extra data so it can be passed through runtime without losing information. </td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Defining_reflection" >Defining reflection</a></td><td class=SDescription>Reflection definitions are facilitated by the <a href="include/reflect/Type-hpp.html#Type.DescriptionHelper" class=LClass id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">Type.DescriptionHelper</a> (or extensions of it), which contains syntactic sugar objects to make reflecting features easier. </td></tr><tr class="SGeneric SIndent1"><td class=SEntry><a href="#Serialization" >Serialization</a></td><td class=SDescription>How to use reflection to save and load things.</td></tr><tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Serialization_and_the_Stack" >Serialization and the Stack</a></td><td class=SDescription>Serialization makes heavy use of the function call stack, recursing on first use of any <a href="include/reflect/Persistent-h.html#Persistent" class=LClass id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">Persistent</a> pointer (on a big graph, this can be very deep).</td></tr><tr class="SGeneric SIndent1"><td class=SEntry><a href="#A_Note_on_Properties" >A Note on Properties</a></td><td class=SDescription><a href="include/reflect/Property-h.html#Property" class=LClass id=link7 onMouseOver="ShowTip(event, 'tt7', 'link7')" onMouseOut="HideTip('tt7')">Properties</a> are <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link8 onMouseOver="ShowTip(event, 'tt3', 'link8')" onMouseOut="HideTip('tt3')">Dynamic</a> objects, reflected as different types for different levels of interfaces. </td></tr><tr class="SSection"><td class=SEntry><a href="#Whining-No" >Whining - No</a></td><td class=SDescription><a href="include/reflect/Reflection-h.html#DECLARE_REFLECTION" class=LMacro id=link9 onMouseOver="ShowTip(event, 'tt8', 'link9')" onMouseOut="HideTip('tt8')">DECLARE_REFLECTION</a> and <a href="include/reflect/Reflection-hpp.html#DEFINE_REFLECTION" class=LMacro id=link10 onMouseOver="ShowTip(event, 'tt9', 'link10')" onMouseOut="HideTip('tt9')">DEFINE_REFLECTION</a> are rather large macros. </td></tr><tr class="SSection"><td class=SEntry><a href="#License" >License</a></td><td class=SDescription>Reflect is released to the public in the hopes that it will do some good in the world. </td></tr><tr class="SSection"><td class=SEntry><a href="#Author" >Author</a></td><td class=SDescription>Adam Freidin, <a href="#" onClick="location.href='mai' + 'lto:' + 'adam.f' + 'reidin' + '@' + 'gmai' + 'l.com'; return false;" class=LEMail>adam.f<span style="display: none">.nosp@m.</span>reidin<span>@</span>gmai<span style="display: none">.nosp@m.</span>l.com</a>.</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Overview"></a>Overview</h2><div class=CBody><p>What Reflect is and why you want to use it.</p><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGeneric"><td class=SEntry><a href="#Features" >Features</a></td><td class=SDescription>Reflect is a complete C++ RTTI framework. </td></tr><tr class="SGeneric SMarked"><td class=SEntry><a href="#Replaces_RTTI" >Replaces RTTI</a></td><td class=SDescription>Reflect does not depend on C++&rsquo;s built-in RTTI: typeid and dynamic_cast. </td></tr><tr class="SGeneric"><td class=SEntry><a href="#The_Two_Faces_of_Reflection" >The Two Faces of Reflection</a></td><td class=SDescription>Reflect, mirroring C++, has two faces: <b>static</b> information known at compiletime, and <b>dynamic</b> information, known at runtime. </td></tr><tr class="SGeneric SMarked"><td class=SEntry><a href="#Unit_Testing" >Unit Testing</a></td><td class=SDescription>Reflect includes its own Unit-<a href="include/reflect/test/Test-h.html#Test" class=LClass id=link11 onMouseOver="ShowTip(event, 'tt1', 'link11')" onMouseOut="HideTip('tt1')">Test</a> framework. </td></tr><tr class="SGeneric"><td class=SEntry><a href="#Philosophy" >Philosophy</a></td><td class=SDescription></td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Features"></a>Features</h3><div class=CBody><p>Reflect is a complete C++ RTTI framework.&nbsp; Reflect allows you to</p><ul><li>inspect types;</li><li>serialize,</li><li>convert, and</li><li>marshal data; and</li><li>unit test components.</li></ul><p>This is done with representative <a href="include/reflect/Type-h.html#Type" class=LClass id=link12 onMouseOver="ShowTip(event, 'tt10', 'link12')" onMouseOut="HideTip('tt10')">Type</a> objects which represent, or reflect, your C++ types.&nbsp; A reflected type is a C++ type that has a Type object associated with it.</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Replaces_RTTI"></a>Replaces RTTI</h3><div class=CBody><p>Reflect does not depend on C++&rsquo;s built-in RTTI: typeid and dynamic_cast.&nbsp; I keep these turned off, they&rsquo;re not completely portable.&nbsp; For instance, typeid.name() is often mangled differently on different platforms/compilers.</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="The_Two_Faces_of_Reflection"></a>The Two Faces of Reflection</h3><div class=CBody><p>Reflect, mirroring C++, has two faces: <b>static</b> information known at compiletime, and <b>dynamic</b> information, known at runtime.&nbsp; Static types of all flavors are reflected by <a href="include/reflect/Type-h.html#Type" class=LClass id=link13 onMouseOver="ShowTip(event, 'tt10', 'link13')" onMouseOut="HideTip('tt10')">Types</a>, <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link14 onMouseOver="ShowTip(event, 'tt3', 'link14')" onMouseOut="HideTip('tt3')">Dynamic</a> types are reflected by <a href="include/reflect/Class-h.html#Class" class=LClass id=link15 onMouseOver="ShowTip(event, 'tt11', 'link15')" onMouseOut="HideTip('tt11')">Class</a>es (which extends <a href="include/reflect/Type-h.html#Type" class=LClass id=link16 onMouseOver="ShowTip(event, 'tt10', 'link16')" onMouseOut="HideTip('tt10')">Type</a>).&nbsp;  The reflection object can be accessed by <a href="include/reflect/Signature-h.html#TypeOf" class=LFunction id=link17 onMouseOver="ShowTip(event, 'tt12', 'link17')" onMouseOut="HideTip('tt12')">TypeOf</a>.&nbsp;  A <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link18 onMouseOver="ShowTip(event, 'tt3', 'link18')" onMouseOut="HideTip('tt3')">Dynamic</a> object also shows its type through the (virtual) <a href="include/reflect/Dynamic-h.html#Dynamic.GetClass" class=LFunction id=link19 onMouseOver="ShowTip(event, 'tt13', 'link19')" onMouseOut="HideTip('tt13')">Dynamic.GetClass</a> method.</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Unit_Testing"></a>Unit Testing</h3><div class=CBody><p>Reflect includes its own Unit-<a href="include/reflect/test/Test-h.html#Test" class=LClass id=link20 onMouseOver="ShowTip(event, 'tt1', 'link20')" onMouseOut="HideTip('tt1')">Test</a> framework.&nbsp; It borrows a little syntax from UnitTest++ (<a href="http://unittest-cpp.sourceforge.net/" class=LURL target=_top>http://unittest-cpp.sourceforge.net/</a>) With the main additional feature that it can associate tests with Types, and print results grouped by Type, so it provides a rough guide of code coverage (and many features omitted).</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Philosophy"></a>Philosophy</h3><div class=CBody><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="Extendable"></a>Extendable</td><td class=CDLDescription><a href="include/reflect/Type-h.html#Type" class=LClass id=link21 onMouseOver="ShowTip(event, 'tt10', 'link21')" onMouseOut="HideTip('tt10')">Type</a> (and <a href="include/reflect/Class-h.html#Class" class=LClass id=link22 onMouseOver="ShowTip(event, 'tt11', 'link22')" onMouseOut="HideTip('tt11')">Class</a>) is extendable, this is done in reflect but you can too!</td></tr><tr><td class=CDLEntry><a name="SURPRISES"></a>SURPRISES</td><td class=CDLDescription>Less please.&nbsp; If you didn&rsquo;t tell reflect something, it&rsquo;s not going to figure it out by parsing header files or any other outside-of-the-compiler magic.&nbsp; This means that some members can be reflected, other can be maintained implicitly, or accessed through functions only.&nbsp; Everything, while assisted as much as feasable with templates, macros, and syntactic sugar cubes, is done manually.&nbsp; I&rsquo;m not claiming that this is always a good thing, but it does allow for some interesting flexibility.</td></tr><tr><td class=CDLEntry><a name="Lightweight"></a>Lightweight</td><td class=CDLDescription>Dynamically reflected objects need no more than their virtual table to identify them to the reflection system.&nbsp;  Static objects have nothing to identify them at runtime, but can be passed around dynamically in a <a href="include/reflect/Variant-h.html#Variant" class=LClass id=link23 onMouseOver="ShowTip(event, 'tt4', 'link23')" onMouseOut="HideTip('tt4')">Variant</a>.</td></tr><tr><td class=CDLEntry><a name="Platform_Integration"></a>Platform Integration</td><td class=CDLDescription>Reflect is designed so that no memory allocations need to be performed before main() starts, making it that much easier to initialize a custom memory system before reflect starts up.</td></tr><tr><td class=CDLEntry><a name="Supports_Change"></a>Supports Change</td><td class=CDLDescription>The serialization pattern reflect uses is capable of dealing with an evolving program.&nbsp;  A member or property added or removed won&rsquo;t invalidate old data, extra data can be ignored without trouble, and missing data was handled by the objects&rsquo; constructor (right??).</td></tr><tr><td class=CDLEntry><a name="Plugin_System"></a>Plugin System</td><td class=CDLDescription>Reflect has macros designed to help automate building DLLs.&nbsp;  Dynamically loaded classes are looked up and used just like resident classes, so Reflect can be used to hide the differences between dynamic and static linking.&nbsp;  By default reflect is configured as an exe, and can load other DLLs and execute them, but it can also be switched to a DLL and linked into another application.</td></tr></table></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Tutorial"></a>Tutorial</h2><div class=CBody><p>Or: Let&rsquo;s see some examples already.</p><p>Lets to start with a <a href="include/reflect/Persistent-h.html#Persistent" class=LClass id=link24 onMouseOver="ShowTip(event, 'tt6', 'link24')" onMouseOut="HideTip('tt6')">Persistent</a>, which is a <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link25 onMouseOver="ShowTip(event, 'tt3', 'link25')" onMouseOut="HideTip('tt3')">Dynamic</a> that can be saved/loaded/edited through its properties.&nbsp;  There are three places we need to look at: declaring reflection in the header file, defining it in the implementation file, and using it somewhere else.</p><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGeneric"><td class=SEntry><a href="#Declaring_Reflection" >Declaring Reflection</a></td><td class=SDescription>Suppose you want to represent Circles by center and radius, you plan to make circle subclass Shape, so it should be at least Dynamic. </td></tr><tr class="SGeneric SMarked"><td class=SEntry><a href="#Defining_Reflection" >Defining Reflection</a></td><td class=SDescription>At this point we have defined the circle type, and declared it and the inner Point type reflected. </td></tr><tr class="SGeneric"><td class=SEntry><a href="#Using_Reflection" >Using Reflection</a></td><td class=SDescription>Some uses of the reflected Circle class</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Declaring_Reflection"></a>Declaring Reflection</h3><div class=CBody><p>Suppose you want to represent Circles by center and radius, you plan to make circle subclass Shape, so it should be at least Dynamic.&nbsp;  You&rsquo;re also writing a tool to edit these circles, so you want to be able to save and load and edit Circles.</p><blockquote><pre>// --- Circle.h

#include &lt;reflect/Persistent.h&gt;
#include &lt;reflect/StructType.h&gt;
#include &lt;cmath&gt;

namespace example {

class Circle                     //    must match
    : public reflect::Persistent // &lt;-------------+
{                                           //    |
    DECLARE_REFLECTION(reflect::Persistent) // &lt;--+
public:
    struct Point
    {
        // default constuctor arguments so this can be default-constructed.
        Point(double x_ = 0, double y_ = 0) : x(x_), y(y_) {}
        double x, y;
    };

    // default constuctor arguments so this can be default-constructed.
    Circle(Point center = Point(), double size = 1.0)
        : mCenter(center)
        , mSize(size)
    {}

    // a regular method call
    void Move(double xstep, double ystep)
    {
        mCenter.x += xstep;
        mCenter.y += ystep;
    }

    // find the distance to another Circle.
    // (overlapping circles have a negative distance)
    double Distance(const Circle &amp;other) const
    {
        double dx = mCenter.x - other.mCenter.x;
        double dy = mCenter.y - other.mCenter.y;

        return std::sqrt(dx*dx + dy*dy) - mSize - other.mSize;
    }

private:
    Point mCenter;
    double mSize;
};

}

DECLARE_STATIC_REFLECTION(local, example::Circle::Point, reflect::StructType)

}</pre></blockquote></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Defining_Reflection"></a>Defining Reflection</h3><div class=CBody><p>At this point we have defined the circle type, and declared it and the inner Point type reflected.&nbsp;  Not much is in the needed in the .h file for declaring reflection.&nbsp; The reflection information for Circle goes in the .cc file.</p><blockquote><pre>// --- Circle.cpp
#include &quot;Circle.h&quot;
#include &lt;reflect/PersistentClass.hpp&gt; // needed for Circle reflection
#include &lt;reflect/StructType.hpp&gt; // needed for Point reflection

DEFINE_REFLECTION(example::Circle, &quot;ex::Circle&quot;)
{
    + Concrete;

    Properties
        (&quot;center&quot;, &amp;example::Circle::mCenter)
            [&quot;tooltip&quot;](&quot;Center of the circle&quot;) // &lt;-- annotation
        (&quot;size&quot;, &amp;example::Circle::mSize)
        ;

    Functions
        (&quot;Distance&quot;, &amp;example::Circle::Distance)
        (&quot;Move&quot;, &amp;example::Circle::Move)
        ;
}

// different reflection macro for external reflection.
DEFINE_STATIC_REFLECTION(Circle::Point, &quot;Circle::Point&quot;)
{
    + Concrete;

    // structs act like tuples.
    Members
        (&amp;Circle::Point::x)
        (&amp;Circle::Point::y)
        ;
}</pre></blockquote></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Using_Reflection"></a>Using Reflection</h3><div class=CBody><p>Some uses of the reflected Circle class</p><blockquote><pre>#include &quot;Circle.h&quot;
#include &lt;reflect/autocast.h&gt;
#include &lt;reflect/function/Function.h&gt; // for using Persistent.Function
#include &lt;reflect/PropertyPath.h&gt; // for using Persistent.Property

void test(reflect::Persistent *a_circle_maybe)
{
    // autocast: like dynamic_cast but less obtrusive
    // and it follows the DRY rule (Don't Repeat Yourself)

    if(example::Circle *circle = a_circle_maybe % reflect::autocast)
    {
        // yes it's a circle
        // use it directly...
        (void)circle;
        printf(&quot;it's a circle\n&quot;);
    }

    // The following assumes something duck-typed like a circle,
    // i.e., has center property, has &quot;Move&quot; and &quot;Distance&quot; functions.

    // but even if it's not... we can still move it using its property
    {
        // reading data with an actual type.
        example::Circle::Point old_center;
        bool read_result = a_circle_maybe-&gt;Property(&quot;center&quot;).ReadData(old_center);

        example::Circle::Point new_center(3,5);
        bool write_result = a_circle_maybe-&gt;Property(&quot;center&quot;).WriteData(new_center);

        // reading the serialized form of a circle::Point
        reflect::String center_text = a_circle_maybe-&gt;Property(&quot;center&quot;).Read();

        // writing a new value using formatted text
        write_result = a_circle_maybe-&gt;Property(&quot;center&quot;).Writef(&quot;%g %g&quot;, 45.6, 24.8);

        (void)read_result;
        (void)write_result;
    }

    // or, let it decide how to move
    if(const reflect::function::Function *move_func = a_circle_maybe-&gt;Function(&quot;Move&quot;))
    {
        function::Parameters move_params(move_func);
        move_params.SetParamValue(0, 2.4); // by reflected value
        move_params.SetParam(1, &quot;27.3&quot;); // or by StandardSerializer data
        if(false == move_func-&gt;Call(a_circle_maybe, move_params))
        {
            // error?
        }
    }

    // A result from a function can be found by the following
    if(const reflect::function::Function *distance_func = a_circle_maybe-&gt;Function(&quot;Distance&quot;))
    {
        function::Parameters distance_params(distance_func);
        distance_params.CopyParamValue(0, *a_circle_maybe);

        if(distance_func-&gt;NumParameters() &gt; 0)
            printf(&quot;Distance wants a %s\n&quot;, distance_params[0].GetType()-&gt;Name());

        double distance;
        reflect::Variant result = reflect::Variant::Ref(distance);
        if(distance_func-&gt;Call(a_circle_maybe, distance_params, result))
        {
            printf(&quot;self circle distance is %g\n&quot;, distance);
        }
    }

    Variant variant = Variant::Ref(*a_circle_maybe);
    reflect::string::String serialized = variant.ToString();

    // save serialized to file ...
    // close program

    // writes something like: &quot;( $center=%d %d; $size=%d; )&quot;

    // open program
    // load serialized from file ...

    Circle clone;
    Variant clone_variant = Variant::Ref(clone);
    clone_variant.FromString(serialized);
}</pre></blockquote></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Implementation"></a>Implementation</h2><div class=CBody><p>The nitty-gritty details.</p><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGeneric"><td class=SEntry><a href="#Signature_and_Dynamic" >Signature and Dynamic</a></td><td class=SDescription>At the center of all of reflect are <a href="include/reflect/Signature-h.html#Signature" class=LClass id=link26 onMouseOver="ShowTip(event, 'tt2', 'link26')" onMouseOut="HideTip('tt2')">Signature</a> and <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link27 onMouseOver="ShowTip(event, 'tt3', 'link27')" onMouseOut="HideTip('tt3')">Dynamic</a>. </td></tr><tr class="SGeneric SMarked"><td class=SEntry><a href="#Variants" >Variants</a></td><td class=SDescription><a href="include/reflect/Variant-h.html#Variant" class=LClass id=link28 onMouseOver="ShowTip(event, 'tt4', 'link28')" onMouseOut="HideTip('tt4')">Variant</a> provides a nice way of wrapping up a static type with some extra data so it can be passed through runtime without losing information. </td></tr><tr class="SGeneric"><td class=SEntry><a href="#Defining_reflection" >Defining reflection</a></td><td class=SDescription>Reflection definitions are facilitated by the <a href="include/reflect/Type-hpp.html#Type.DescriptionHelper" class=LClass id=link29 onMouseOver="ShowTip(event, 'tt5', 'link29')" onMouseOut="HideTip('tt5')">Type.DescriptionHelper</a> (or extensions of it), which contains syntactic sugar objects to make reflecting features easier. </td></tr><tr class="SGeneric SMarked"><td class=SEntry><a href="#Serialization" >Serialization</a></td><td class=SDescription>How to use reflection to save and load things.</td></tr><tr class="SGeneric"><td class=SEntry><a href="#Serialization_and_the_Stack" >Serialization and the Stack</a></td><td class=SDescription>Serialization makes heavy use of the function call stack, recursing on first use of any <a href="include/reflect/Persistent-h.html#Persistent" class=LClass id=link30 onMouseOver="ShowTip(event, 'tt6', 'link30')" onMouseOut="HideTip('tt6')">Persistent</a> pointer (on a big graph, this can be very deep).</td></tr><tr class="SGeneric SMarked"><td class=SEntry><a href="#A_Note_on_Properties" >A Note on Properties</a></td><td class=SDescription><a href="include/reflect/Property-h.html#Property" class=LClass id=link31 onMouseOver="ShowTip(event, 'tt7', 'link31')" onMouseOut="HideTip('tt7')">Properties</a> are <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link32 onMouseOver="ShowTip(event, 'tt3', 'link32')" onMouseOut="HideTip('tt3')">Dynamic</a> objects, reflected as different types for different levels of interfaces. </td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Signature_and_Dynamic"></a>Signature and Dynamic</h3><div class=CBody><p>At the center of all of reflect are <a href="include/reflect/Signature-h.html#Signature" class=LClass id=link33 onMouseOver="ShowTip(event, 'tt2', 'link33')" onMouseOut="HideTip('tt2')">Signature</a> and <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link34 onMouseOver="ShowTip(event, 'tt3', 'link34')" onMouseOut="HideTip('tt3')">Dynamic</a>.&nbsp; <a href="include/reflect/Signature-h.html#Signature" class=LClass id=link35 onMouseOver="ShowTip(event, 'tt2', 'link35')" onMouseOut="HideTip('tt2')">Signature</a> is the struct template that provides compiletime access to <a href="include/reflect/Type-h.html#Type" class=LClass id=link36 onMouseOver="ShowTip(event, 'tt10', 'link36')" onMouseOut="HideTip('tt10')">Type</a> objects and the virtual function which provides runtime access.&nbsp;  A Signature provides a typedef for the class type and a method <a href="include/reflect/Signature-h.html#Signature.TheClass" class=LFunction id=link37 onMouseOver="ShowTip(event, 'tt14', 'link37')" onMouseOut="HideTip('tt14')">Signature::TheClass</a> for accessing it.&nbsp;  A <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link38 onMouseOver="ShowTip(event, 'tt3', 'link38')" onMouseOut="HideTip('tt3')">Dynamic</a> also provides a typedef for the class type and static method <a href="include/reflect/Dynamic-h.html#Dynamic.TheClass" class=LFunction id=link39 onMouseOver="ShowTip(event, 'tt15', 'link39')" onMouseOut="HideTip('tt15')">Dynamic::TheClass</a> to access it, as well as a virtual method <a href="include/reflect/Dynamic-h.html#Dynamic.GetClass" class=LFunction id=link40 onMouseOver="ShowTip(event, 'tt13', 'link40')" onMouseOut="HideTip('tt13')">Dynamic.GetClass</a>.</p><p>The static typedef allows subclasses of Dynamics to inherit their parents&rsquo; <a href="include/reflect/Class-h.html#Class" class=LClass id=link41 onMouseOver="ShowTip(event, 'tt11', 'link41')" onMouseOut="HideTip('tt11')">Class</a> type unless it&rsquo;s overridden.&nbsp;  When overriding <a href="include/reflect/Class-h.html#Class" class=LClass id=link42 onMouseOver="ShowTip(event, 'tt11', 'link42')" onMouseOut="HideTip('tt11')">Class</a> types, a subclass must use a subclass of the parents&rsquo; class type (this is actually enforced at compile time because <a href="include/reflect/Dynamic-h.html#Dynamic.GetClass" class=LFunction id=link43 onMouseOver="ShowTip(event, 'tt13', 'link43')" onMouseOut="HideTip('tt13')">Dynamic.GetClass</a> takes advantage of covariance in its return type: i.e., a <a href="include/reflect/Persistent-h.html#Persistent" class=LClass id=link44 onMouseOver="ShowTip(event, 'tt6', 'link44')" onMouseOut="HideTip('tt6')">Persistent</a> returns a <a href="include/reflect/PersistentClass-h.html#PersistentClass" class=LClass id=link45 onMouseOver="ShowTip(event, 'tt16', 'link45')" onMouseOut="HideTip('tt16')">PersistentClass</a> from GetClass even though it&rsquo;s a virtual declared to return a <a href="include/reflect/Class-h.html#Class" class=LClass id=link46 onMouseOver="ShowTip(event, 'tt11', 'link46')" onMouseOut="HideTip('tt11')">Class</a>).</p><p>The main use of <a href="include/reflect/Signature-h.html#Signature" class=LClass id=link47 onMouseOver="ShowTip(event, 'tt2', 'link47')" onMouseOut="HideTip('tt2')">Signature</a> is the <a href="include/reflect/Signature-h.html#TypeOf" class=LFunction id=link48 onMouseOver="ShowTip(event, 'tt12', 'link48')" onMouseOut="HideTip('tt12')">TypeOf</a> template function, which obviates the typing of Signature&lt;T&gt;::TheClass() with the more readable TypeOf&lt;T&gt;().&nbsp;  The main use of <a href="include/reflect/Dynamic-h.html#Dynamic.GetClass" class=LFunction id=link49 onMouseOver="ShowTip(event, 'tt13', 'link49')" onMouseOut="HideTip('tt13')">Dynamic.GetClass</a> is the <a href="include/reflect/autocast-h.html#autocast" class=LVariable id=link50 onMouseOver="ShowTip(event, 'tt17', 'link50')" onMouseOut="HideTip('tt17')">autocast</a> object, which is a syntactic sugar object superior to dynamic_cast.</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Variants"></a>Variants</h3><div class=CBody><p><a href="include/reflect/Variant-h.html#Variant" class=LClass id=link51 onMouseOver="ShowTip(event, 'tt4', 'link51')" onMouseOut="HideTip('tt4')">Variant</a> provides a nice way of wrapping up a static type with some extra data so it can be passed through runtime without losing information.&nbsp;  <a href="include/reflect/Variant-h.html#Variant" class=LClass id=link52 onMouseOver="ShowTip(event, 'tt4', 'link52')" onMouseOut="HideTip('tt4')">Variant</a>&rsquo;s handle a lot of cases, they can own their data, or reference existing data, (possibly const data), they can <a href="include/reflect/Variant-h.html#Variant.Alias" class=LFunction id=link53 onMouseOver="ShowTip(event, 'tt18', 'link53')" onMouseOut="HideTip('tt18')">Variant.Alias</a> data, which is interesting when passing parameters of not-quite-the-right-type by reference into reflected functions.&nbsp; Variant&rsquo;s can also be typed without having values.&nbsp;  Variants are reference counted (actually a circular linked list is used), so constructed data can be shared among variants efficiently.</p><p>In order to implement variant we have the concept of an opaque pointer: a cannoical void * pointer to an object (we need pointers canonicallized to deal with multiple inheritance).&nbsp; At runtime, an opaque pointer and a <a href="include/reflect/Type-h.html#Type" class=LClass id=link54 onMouseOver="ShowTip(event, 'tt10', 'link54')" onMouseOut="HideTip('tt10')">Type</a> is just as good as a statically-typed value.&nbsp;  Opaque values can be manipulated with the <a href="include/reflect/Type-h.html#Type.ConvertValue" class=LFunction id=link55 onMouseOver="ShowTip(event, 'tt19', 'link55')" onMouseOut="HideTip('tt19')">Type.ConvertValue</a> method, which converts one value into another, this is used extensively in <a href="include/reflect/Variant-h.html#Variant" class=LClass id=link56 onMouseOver="ShowTip(event, 'tt4', 'link56')" onMouseOut="HideTip('tt4')">Variant</a> and probably does not need to be accessed directly.</p><p>Each class provides methods <a href="include/reflect/Type-h.html#Type.OpaqueCast" class=LFunction id=link57 onMouseOver="ShowTip(event, 'tt20', 'link57')" onMouseOut="HideTip('tt20')">Type.OpaqueCast</a> and <a href="include/reflect/Type-h.html#Type.TranslucentCast" class=LFunction id=link58 onMouseOver="ShowTip(event, 'tt21', 'link58')" onMouseOut="HideTip('tt21')">Type.TranslucentCast</a> to convert typed pointers to and from opaque ones.&nbsp;  However, rather than using the awkward</p><blockquote><pre>T *t_ptr;
void *opaque = Signature&lt;T&gt;::ClassType::OpaqueCast(t_ptr);
t_ptr = Signature&lt;T&gt;::ClassType::template TranslucentCast&lt;Target&gt;(opaque)</pre></blockquote><p>please use <a href="include/reflect/Signature-h.html#opaque_cast" class=LFunction id=link59 onMouseOver="ShowTip(event, 'tt22', 'link59')" onMouseOut="HideTip('tt22')">opaque_cast</a> and <a href="include/reflect/Signature-h.html#translucent_cast" class=LFunction id=link60 onMouseOver="ShowTip(event, 'tt23', 'link60')" onMouseOut="HideTip('tt23')">translucent_cast</a></p><blockquote><pre>T *t_ptr;
void *opaque = opaque_cast(t_ptr);
t_ptr = translucent_cast&lt;T *&gt;(t_ptr);</pre></blockquote><p>Variants use this internally, as does the Property system.&nbsp; In general, if you see a static_cast in your code, always consider using an opaque instead.</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Defining_reflection"></a>Defining reflection</h3><div class=CBody><p>Reflection definitions are facilitated by the <a href="include/reflect/Type-hpp.html#Type.DescriptionHelper" class=LClass id=link61 onMouseOver="ShowTip(event, 'tt5', 'link61')" onMouseOut="HideTip('tt5')">Type.DescriptionHelper</a> (or extensions of it), which contains syntactic sugar objects to make reflecting features easier.&nbsp;  The description helper type is friended in the <a href="include/reflect/Reflection-h.html#DECLARE_REFLECTION" class=LMacro id=link62 onMouseOver="ShowTip(event, 'tt8', 'link62')" onMouseOut="HideTip('tt8')">DECLARE_REFLECTION</a> macro, so pointers to private members can be referenced in the reflection definition.</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Serialization"></a>Serialization</h3><div class=CBody><p>How to use reflection to save and load things.</p><p>Above, you see a fairly basic use of serialization.&nbsp; Most of the time, you will want to use the <a href="include/reflect/serialize/StandardSerializer-h.html#StandardSerializer" class=LClass id=link63 onMouseOver="ShowTip(event, 'tt24', 'link63')" onMouseOut="HideTip('tt24')">StandardSerializer</a> or the <a href="include/reflect/serialize/ShallowSerializer-h.html#ShallowSerializer" class=LClass id=link64 onMouseOver="ShowTip(event, 'tt25', 'link64')" onMouseOut="HideTip('tt25')">ShallowSerializer</a> modification of it.&nbsp;  There are times when this is insufficient, like</p><ul><li>when floating point numbers can&rsquo;t take being decimalized and reparsed, or</li><li>when text is too big, and you want binary.</li></ul><p>Serialization operates with a few primitive data token types</p><ul><li>bool</li><li>long</li><li>double</li><li>string</li><li>binary data</li></ul><p>and tags which provide a hierarchical structure like XML, but (in the StandardSerializer format) with only one-token lookahead to determine tag type.&nbsp;  (It would be possible to implement streaming XML serializers/deserializers using the same interface.)</p><p>Serializers are driven by writing data to them, as well as providing structure with <a href="include/reflect/Serializer-h.html#Serializer.Begin" class=LFunction id=link65 onMouseOver="ShowTip(event, 'tt26', 'link65')" onMouseOut="HideTip('tt26')">Serializer.Begin</a> and <a href="include/reflect/Serializer-h.html#Serializer.End" class=LFunction id=link66 onMouseOver="ShowTip(event, 'tt27', 'link66')" onMouseOut="HideTip('tt27')">Serializer.End</a>.&nbsp;  A <a href="include/reflect/Deserializer-h.html#Deserializer" class=LClass id=link67 onMouseOver="ShowTip(event, 'tt28', 'link67')" onMouseOut="HideTip('tt28')">Deserializer</a> executed on the output of a Serializer with the parallel calls should read data very similar to the data written.</p><p>The hierarchical structure of streams allows derializers to skip unknown sections of data.&nbsp;  Skipping happens when the <a href="include/reflect/Deserializer-h.html#Deserializer.End" class=LFunction id=link68 onMouseOver="ShowTip(event, 'tt29', 'link68')" onMouseOut="HideTip('tt29')">Deserializer.End</a> method is called but an end tag is not in the stream, if the serializer supports skipping, it will try to read and discard data and tags until the matching end tag is reached.&nbsp;  Not all serializers need to support skipping, but it is highly recommended that data is persisted in a form that does.&nbsp; (The <a href="include/reflect/serialize/StandardSerializer-h.html#StandardSerializer" class=LClass id=link69 onMouseOver="ShowTip(event, 'tt24', 'link69')" onMouseOut="HideTip('tt24')">StandardSerializer</a> does, of course, support skipping data).</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Serialization_and_the_Stack"></a>Serialization and the Stack</h3><div class=CBody><p>Serialization makes heavy use of the function call stack, recursing on first use of any <a href="include/reflect/Persistent-h.html#Persistent" class=LClass id=link70 onMouseOver="ShowTip(event, 'tt6', 'link70')" onMouseOut="HideTip('tt6')">Persistent</a> pointer (on a big graph, this can be very deep).</p><p>It might be possible to delay serializing/deserializing any properties of pointers: do a shallow serialization, remembering all pointer properties, and then repeatedly flush and serialize remaining new pointers into the stream as a finalization step.&nbsp; Thoughts?</p></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="A_Note_on_Properties"></a>A Note on Properties</h3><div class=CBody><p><a href="include/reflect/Property-h.html#Property" class=LClass id=link71 onMouseOver="ShowTip(event, 'tt7', 'link71')" onMouseOut="HideTip('tt7')">Properties</a> are <a href="include/reflect/Dynamic-h.html#Dynamic" class=LClass id=link72 onMouseOver="ShowTip(event, 'tt3', 'link72')" onMouseOut="HideTip('tt3')">Dynamic</a> objects, reflected as different types for different levels of interfaces.&nbsp;  The particular implementations are not reflected, C++ polymorphism takes over from there.&nbsp;  The property system illustrates when reflection is good, and when to abandon it: there is no rule that a subclass of a reflected object must be reflected, but take care when serializing such objects, because they will be sliced.</p></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Whining-No"></a>Whining - No</h2><div class=CBody><p><a href="include/reflect/Reflection-h.html#DECLARE_REFLECTION" class=LMacro id=link73 onMouseOver="ShowTip(event, 'tt8', 'link73')" onMouseOut="HideTip('tt8')">DECLARE_REFLECTION</a> and <a href="include/reflect/Reflection-hpp.html#DEFINE_REFLECTION" class=LMacro id=link74 onMouseOver="ShowTip(event, 'tt9', 'link74')" onMouseOut="HideTip('tt9')">DEFINE_REFLECTION</a> are rather large macros.&nbsp;  While it is possible to do a lot more of the work using template injection, it caused problems making reflected DLLs/SharedObjects, so that approach was abandoned.&nbsp; Template injection is not debugger friendly, nor is it constructor friendly, so it has other drawbacks which outweigh the stylistic issues with macro injection methods.&nbsp;  Sometimes the debugger will step through these macros, but the work done in these is minimal and safe.</p><p>Exceptions are not used in Reflect, due mainly to my unfamiliarity with them and that the original target of its (proprietary) spiritual predecessor miniork (<a href="http://www.tweakoz.com/" class=LURL target=_top>http://www.tweakoz.com/</a>) was embedded development.&nbsp; Exceptions would make certain actions well defined (what happens when you request the wrong Type as a reference from a variant?)</p><p>Don&rsquo;t register two properties with the same name in a single inheritance chain or two classes with the same name anywhere, the serialization mechanisms will fail.&nbsp;  If error checking these conditions is necessary, then <a href="include/reflect/Type-h.html#Type.LoadTypes" class=LFunction id=link75 onMouseOver="ShowTip(event, 'tt30', 'link75')" onMouseOut="HideTip('tt30')">Type::LoadTypes</a> would have to be extended to possibly fail and cleanup these cases.</p><p>Reflect requires a modern C++ compiler, it was developed to support both Visual Studio 2008 Express and gcc 4.3.1.</p></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="License"></a>License</h2><div class=CBody><p>Reflect is released to the public in the hopes that it will do some good in the world.&nbsp;  Ideally it (and it&rsquo;s horrible machinations) will actually convince people to stop using C++, or at least use it less and cross-script more.</p></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Author"></a>Author</h2><div class=CBody><p>Adam Freidin, <a href="#" onClick="location.href='mai' + 'lto:' + 'adam.f' + 'reidin' + '@' + 'gmai' + 'l.com'; return false;" class=LEMail>adam.f<span style="display: none">.nosp@m.</span>reidin<span>@</span>gmai<span style="display: none">.nosp@m.</span>l.com</a>.</p><h4 class=CHeading>Special Thanks To</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Michael Mayers</td><td class=CDLDescription><a href="http://www.tweakoz.com/" class=LURL target=_top>http://www.tweakoz.com/</a>, for that which came before.</td></tr><tr><td class=CDLEntry>Hayley Goerisch</td><td class=CDLDescription>for putting up with me and my midnight coding.</td></tr><tr><td class=CDLEntry>Santa Cruz Games</td><td class=CDLDescription>for letting this code out.</td></tr></table></div></div></div>

</div><!--Content-->


<div id=Footer>&copy; 2008 Adam Freidin&nbsp; &middot;&nbsp; <a href="http://www.naturaldocs.org">Generated by Natural Docs</a></div><!--Footer-->


<div id=Menu><div class=MTitle>Reflect<div class=MSubTitle>Serialization and Scripting for C++</div></div><div class=MEntry><div class=MFile id=MSelected>Overview</div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Reflection</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MFile><a href="include/reflect/Signature-h.html">Signature</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/Reflection-h.html">Reflection.h</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/Reflection-hpp.html">Reflection.hpp</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/config/ReflectExport-h.html">ReflectExport</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/Variant-h.html">Variant</a></div></div><div class=MEntry><div class=MText>-- Static --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/Type-h.html">Type</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/Type-hpp.html">Type.hpp</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/EnumType-h.html">EnumType</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/EnumType-hpp.html">EnumType.hpp</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/PrimitiveTypes-h.html">PrimitiveTypes.h</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/ObjectType-h.html">ObjectType</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/ObjectType-hpp.html">ObjectType.hpp</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/StructType-h.html">StructType</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/StructType-hpp.html">StructType.hpp</a></div></div><div class=MEntry><div class=MText>-- Dynamic --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/Dynamic-h.html">Dynamic</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/Class-h.html">Class</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/Class-hpp.html">Class.hpp</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/autocast-h.html">autocast</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent2')">Persistent</a><div class=MGroupContent id=MGroupContent2><div class=MEntry><div class=MFile><a href="include/reflect/Persistent-h.html">Persistent</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/PersistentClass-h.html">PersistentClass</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/PersistentClass-hpp.html">PersistentClass.hpp</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/PropertyPath-h.html">PropertyPath</a></div></div><div class=MEntry><div class=MText>-- Property --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/Property-h.html">Property</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/DataProperty-h.html">DataProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/ArrayProperty-h.html">ArrayProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/MapProperty-h.html">MapProperty</a></div></div><div class=MEntry><div class=MText>-- Property Implementations --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/AccessorAccessProperty-h.html">AccessorAccessProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/AccessorDirectProperty-h.html">AccessorDirectProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/AccessorIndirectProperty-h.html">AccessorIndirectProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/AccessorProperty-h.html">AccessorProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/BaseClassProperty-h.html">BaseClassProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/DirectArrayProperty-h.html">DirectArrayProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/DirectDataProperty-h.html">DirectDataProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/DirectMapProperty-h.html">DirectMapProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/DirectVectorProperty-h.html">DirectVectorProperty</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/property/VariantProperty-h.html">VariantProperty</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent3')">Utility</a><div class=MGroupContent id=MGroupContent3><div class=MEntry><div class=MFile><a href="include/reflect/utility/Context-h.html">Context&lt;Type&gt;</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/utility/SaveLoad-h.html">SaveLoad.h</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent4')">Function</a><div class=MGroupContent id=MGroupContent4><div class=MEntry><div class=MFile><a href="include/reflect/function/Function-hpp.html">CreateFunction</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/function/Function-h.html">Function</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/function/FunctionSignature-hpp.html">FunctionSignature.hpp</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent5')">Execute</a><div class=MGroupContent id=MGroupContent5><div class=MEntry><div class=MFile><a href="include/reflect/execute/Application-h.html">Application</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/execute/ApplicationClass-h.html">ApplicationClass</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/execute/ApplicationClass-hpp.html">ApplicationClass::<wbr>DescriptionHelper</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent6')">Serialize</a><div class=MGroupContent id=MGroupContent6><div class=MEntry><div class=MFile><a href="include/reflect/Reflector-h.html">Reflector</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/InputStream-h.html">InputStream</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/OutputStream-h.html">OutputStream</a></div></div><div class=MEntry><div class=MText>-- Core Interface --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/Serializer-h.html">Serializer</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/Deserializer-h.html">Deserializer</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/SerializationTag-h.html">SerializationTag</a></div></div><div class=MEntry><div class=MText>-- Implementation --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/serialize/StandardSerializer-h.html">StandardSerializer</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/serialize/StandardDeserializer-h.html">StandardDeserializer</a></div></div><div class=MEntry><div class=MText>-- Utility --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/serialize/CompositeSerializer-h.html">CompositeSerializer</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/serialize/CompositeDeserializer-h.html">CompositeDeserializer</a></div></div><div class=MEntry><div class=MText>-- Modified --</div></div><div class=MEntry><div class=MFile><a href="include/reflect/serialize/ShallowSerializer-h.html">ShallowSerializer</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/serialize/ShallowDeserializer-h.html">ShallowDeserializer</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent7')">String</a><div class=MGroupContent id=MGroupContent7><div class=MEntry><div class=MFile><a href="include/reflect/string/BlockString-h.html">BlockString</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/string/ConstString-h.html">ConstString</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/string/Fragment-h.html">Fragment</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/string/MutableString-h.html">MutableString</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/string/SharedString-h.html">SharedString</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/string/StringBlock-h.html">StringBlock</a></div></div><div class=MEntry><div class=MFile><a href="include/reflect/string/StringPool-h.html">StringPool</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent8')">Testing</a><div class=MGroupContent id=MGroupContent8><div class=MEntry><div class=MFile><a href="include/reflect/test/Test-h.html">Test</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent9')">SpiderMonkey</a><div class=MGroupContent id=MGroupContent9><div class=MEntry><div class=MFile><a href="include/reflect_js/JavaScript-h.html">JavaScript</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent10')">Browse Index</a><div class=MGroupContent id=MGroupContent10><div class=MEntry><div class=MIndex><a href="../index/General.html">Index</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Classes.html">Classes</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Constants.html">Constants</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Files.html">Files</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Functions.html">Functions</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Macros.html">Macros</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Members.html">Members</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Types.html">Types</a></div></div></div></div></div><script type="text/javascript"><!--
var searchPanel = new SearchPanel("searchPanel", "HTML", "../search");
--></script><div id=MSearchPanel class=MSearchPanelInactive><input type=text id=MSearchField value=Search onFocus="searchPanel.OnSearchFieldFocus(true)" onBlur="searchPanel.OnSearchFieldFocus(false)" onKeyUp="searchPanel.OnSearchFieldChange()"><select id=MSearchType onFocus="searchPanel.OnSearchTypeFocus(true)" onBlur="searchPanel.OnSearchTypeFocus(false)" onChange="searchPanel.OnSearchTypeChange()"><option  id=MSearchEverything selected value="General">Everything</option><option value="Classes">Classes</option><option value="Constants">Constants</option><option value="Files">Files</option><option value="Functions">Functions</option><option value="Macros">Macros</option><option value="Members">Members</option><option value="Types">Types</option></select></div><script language=JavaScript><!--
HideAllBut([], 11);// --></script></div><!--Menu-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Test : public Dynamic</td></tr></table></td></tr></table></blockquote>Each subclass of Test implements a unit test.</div></div><div class=CToolTip id="tt2"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>template&lt;typename T&gt; struct Signature</td></tr></table></blockquote>Signatures provide a uniform means of accessing the Class object and the static type of that class of any reflected type, dynamic (Dynamic) or not.</div></div><div class=CToolTip id="tt3"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Dynamic</td></tr></table></td></tr></table></blockquote>This class defines the core interface for all runtime type identification (RTTI) in reflect.</div></div><div class=CToolTip id="tt4"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Variant</td></tr></table></td></tr></table></blockquote>Variants represent objects of any reflected type. </div></div><div class=CToolTip id="tt5"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>template&lt;typename T&gt; class Type::DescriptionHelper</td></tr></table></blockquote>Template base class for description helpers, used in reflection definitions.</div></div><div class=CToolTip id="tt6"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Persistent : public Dynamic</td></tr></table></td></tr></table></blockquote>The base class of all objects that can be saved and loaded. </div></div><div class=CToolTip id="tt7"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Property : public Dynamic</td></tr></table></td></tr></table></blockquote>Properties represent data in a reflected type, and can be used to Serialize that data through a Reflector.</div></div><div class=CToolTip id="tt8"><div class=CMacro>Declares reflection for a class.</div></div><div class=CToolTip id="tt9"><div class=CMacro>Defines the reflection support for a type using its class&rsquo; DescriptionHelper.</div></div><div class=CToolTip id="tt10"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Type : public Dynamic</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt11"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Class : public ObjectType</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt12"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>template&lt;typename T&gt; inline typename Signature&lt;T&gt;::ClassType *TypeOf()</td></tr></table></blockquote>Templated function, returns the Class of a reflected type.</div></div><div class=CToolTip id="tt13"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual ClassType *GetClass() const</td></tr></table></blockquote>The dynamic Class of the castable.</div></div><div class=CToolTip id="tt14"><div class=CFunction>Returns the Class of the type represented by this signature.</div></div><div class=CToolTip id="tt15"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static ClassType *TheClass()</td></tr></table></blockquote>This function is always hidden by subclasses and used during static construction to construct the class hierarchy.</div></div><div class=CToolTip id="tt16"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) PersistentClass : public Class</td></tr></table></td></tr></table></blockquote>This class enables serialization and stores property maps.</div></div><div class=CToolTip id="tt17"><div class=CVariable><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static const struct autocast_token { autocast_token(){} } autocast</td></tr></table></blockquote>Provides an easy way to downcast Dynamics without having to specify the downcast target type, and with minimal interruption to the legible program flow.</div></div><div class=CToolTip id="tt18"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>bool Alias(</td><td class=PType nowrap>Variant&nbsp;</td><td class=PParameterPrefix nowrap>&amp;</td><td class=PParameter nowrap>value</td><td class=PAfterParameters nowrap>)</td></tr></table></td></tr></table></blockquote>This is a special function, for reflected parameters to reflected function calls.</div></div><div class=CToolTip id="tt19"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>virtual bool ConvertValue(</td><td class=PTypePrefix nowrap></td><td class=PType nowrap>void&nbsp;</td><td class=PParameterPrefix nowrap>*</td><td class=PParameter nowrap>opaque,</td></tr><tr><td></td><td class=PTypePrefix nowrap>const&nbsp;</td><td class=PType nowrap>void&nbsp;</td><td class=PParameterPrefix nowrap>*</td><td class=PParameter nowrap>source,</td></tr><tr><td></td><td class=PTypePrefix nowrap>const&nbsp;</td><td class=PType nowrap>Type&nbsp;</td><td class=PParameterPrefix nowrap>*</td><td class=PParameter nowrap>from</td><td class=PAfterParameters nowrap>) const</td></tr></table></td></tr></table></blockquote>Uses conversions registered with RegisterConversion.</div></div><div class=CToolTip id="tt20"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>template&lt;typename Type&gt; static void *OpaqueCast(</td><td class=PType nowrap>Type&nbsp;</td><td class=PParameterPrefix nowrap>*</td><td class=PParameter nowrap>ptr</td><td class=PAfterParameters nowrap>)</td></tr></table></td></tr></table></blockquote>Casts a type represented by this Type to a void *, used by Serialize. </div></div><div class=CToolTip id="tt21"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>template&lt;typename T&gt; static T *TranslucentCast(</td><td class=PType nowrap>void&nbsp;</td><td class=PParameterPrefix nowrap>*</td><td class=PParameter nowrap>ptr</td><td class=PAfterParameters nowrap>)</td></tr></table></td></tr></table></blockquote>Casts a void * from OpaqueCast back to a Type. </div></div><div class=CToolTip id="tt22"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>template&lt;typename T&gt; inline void *opaque_cast(</td><td class=PType nowrap>T&nbsp;</td><td class=PParameterPrefix nowrap>*</td><td class=PParameter nowrap>value</td><td class=PAfterParameters nowrap>)</td></tr></table></td></tr></table></blockquote>Turns a typed pointer (of type Type *) into an opaque pointer (a void *), for use with the class Signature::TheClass. </div></div><div class=CToolTip id="tt23"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>template&lt;typename Type&gt; inline Type translucent_cast(</td><td class=PType nowrap>void&nbsp;</td><td class=PParameterPrefix nowrap>*</td><td class=PParameter nowrap>value</td><td class=PAfterParameters nowrap>)</td></tr></table></td></tr></table></blockquote>Turns an opaque pointer (of type void *) into a typed pointer of the specified type. </div></div><div class=CToolTip id="tt24"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) StandardSerializer : public Serializer</td></tr></table></td></tr></table></blockquote>A basic ascii text serializer.</div></div><div class=CToolTip id="tt25"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) ShallowSerializer : public CompositeSerializer</td></tr></table></td></tr></table></blockquote>A composite serializer that serializes pointers as raw data rather than traversing them.</div></div><div class=CToolTip id="tt26"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>virtual bool Begin(</td><td class=PTypePrefix nowrap>const&nbsp;</td><td class=PType nowrap>SerializationTag&nbsp;</td><td class=PParameterPrefix nowrap>&amp;</td><td class=PParameter nowrap></td><td class=PAfterParameters nowrap>) = 0</td></tr></table></td></tr></table></blockquote>Starts a group, annotated by the tag&rsquo;s type and text. </div></div><div class=CToolTip id="tt27"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>virtual bool End(</td><td class=PTypePrefix nowrap>const&nbsp;</td><td class=PType nowrap>SerializationTag&nbsp;</td><td class=PParameterPrefix nowrap>&amp;</td><td class=PParameter nowrap></td><td class=PAfterParameters nowrap>) = 0</td></tr></table></td></tr></table></blockquote>Ends a group started by the tag with Begin.</div></div><div class=CToolTip id="tt28"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>class ReflectExport(</td><td class=PParameter nowrap>reflect</td><td class=PAfterParameters nowrap>) Deserializer</td></tr></table></td></tr></table></blockquote>Defines the interface for deserialization.</div></div><div class=CToolTip id="tt29"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class=PBeforeParameters nowrap>virtual bool End(</td><td class=PType nowrap>SerializationTag&nbsp;</td><td class=PParameterPrefix nowrap>&amp;</td><td class=PParameter nowrap></td><td class=PAfterParameters nowrap>) = 0</td></tr></table></td></tr></table></blockquote>Deserializes an ending tag in the stream. </div></div><div class=CToolTip id="tt30"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static Type *LoadTypes()</td></tr></table></blockquote>Initializes all types which have been static initialized.</div></div><!--END_ND_TOOLTIPS-->




<div id=MSearchResultsWindow><iframe src="" frameborder=0 name=MSearchResults id=MSearchResults></iframe><a href="javascript:searchPanel.CloseResultsWindow()" id=MSearchResultsWindowClose>Close</a></div>


<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>